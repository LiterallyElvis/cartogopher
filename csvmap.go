package csvmap

import (
	"encoding/csv"
	"log"
	"os"
)

type CSVMap struct {
	Headers        []string
	HeaderIndexMap map[string]int
	FileContents   []map[string]string
}

func closeIfError(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

// Creates a map of header strings to their indices in the array generated by 
// encoding/csv's reader. For instance, if your CSV file looks something like
// this:
//         ---------------------
//         | one | two | three |
//         ---------------------
//         |  A  |  B  |   C   |
//         ---------------------
// Go's generated array for the header row will be [ "one", "two", "three" ]. 
// csvmap's generated map for the header row will be { "one": 1, "two": 2, "three": 3 }
func (m *CSVMap) CreateHeaderIndexMap(headers []string) map[string]int {
	headerIndexMap := make(map[string]int, len(headers))

	for index, header := range headers {
		headerIndexMap[header] = index
	}

	return headerIndexMap
}

// Takes a given CSV array and returns a map of column names to the values contained therein.
// For instance, if your CSV file looks something like this:
//         ---------------------
//         | one | two | three |
//         ---------------------
//         |  A  |  B  |   C   |
//         ---------------------
// The return result will be:
//     {
//		   "one": "A",
//		   "two": "B",
//		   "three": "C",
//	   }
func (m *CSVMap) CreateRowMap(csvRow []string) map[string]string {
	result := map[string]string{}
	for header, index := range m.HeaderIndexMap {
		result[header] = csvRow[index]
	}

	return result
}

// Goes through an entire CSV file and returns a slice of maps for every row.
// Note that this is not very wise to do. It's hilariously expensive, scales
// horribly if at all, and probably shouldn't have even been written. I'll probably
// replace it immediately upon having the time to do so.
func (m *CSVMap) CreateAllMaps(fileContents [][]string) []map[string]string {
	result := []map[string]string{}

	for _, row := range fileContents {
		newRow := map[string]string{}
		for header, index := range m.HeaderIndexMap {
			newRow[header] = row[index]
		}
		result = append(result, newRow)
	}

	return result
}

// returns a new CSVMap object.
func New(filePath string) *CSVMap {
	// Open our file.
	inputCSV, err := os.Open(filePath)
	if err != nil {
		log.Fatal(err)
	}
	defer inputCSV.Close()
	reader := csv.NewReader(inputCSV)

	// Create our resulting struct
	output := &CSVMap{}

	inputHeaders, err := reader.Read()
	closeIfError(err)

	// Use our methods (defined above) to populate our struct fields
	output.Headers = inputHeaders
	output.HeaderIndexMap = output.CreateHeaderIndexMap(inputHeaders)

	remainderOfFile, err := reader.ReadAll()
	closeIfError(err)

	output.CreateAllMaps(remainderOfFile, output.HeaderIndexMap)

	return output
}
