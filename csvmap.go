package cartogopher

import (
	"encoding/csv"
	"os"
)

type CSVMap struct {
	Headers        []string
	HeaderIndexMap map[string]int
	Reader         *csv.Reader
}

// Creates a map of header strings to their indices in the array generated by
// encoding/csv's reader. For instance, if your CSV file looks something like
// this:
//         ---------------------
//         | one | two | three |
//         ---------------------
//         |  A  |  B  |   C   |
//         ---------------------
// Go's generated array for the header row will be [ "one", "two", "three" ].
// csvmap's generated map for the header row will be { "one": 1, "two": 2, "three": 3 }
func (m *CSVMap) CreateHeaderIndexMap(headers []string) map[string]int {
	headerIndexMap := make(map[string]int, len(headers))

	for index, header := range headers {
		headerIndexMap[header] = index
	}

	return headerIndexMap
}

// Takes a given CSV array and returns a map of column names to the values contained therein.
// For instance, if your CSV file looks something like this:
//         ---------------------
//         | one | two | three |
//         ---------------------
//         |  A  |  B  |   C   |
//         ---------------------
// The return result will be:
//     {
//		   "one": "A",
//		   "two": "B",
//		   "three": "C",
//	   }
func (m *CSVMap) CreateRowMap(csvRow []string) map[string]string {
	result := map[string]string{}
	for header, index := range m.HeaderIndexMap {
		result[header] = csvRow[index]
	}

	return result
}

// returns a new CSVMap object.
func NewFromFilePath(filePath string) (*CSVMap, error) {
	// Open our file.
	inputCSV, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer inputCSV.Close()
	reader := csv.NewReader(inputCSV)

	// Create our resulting struct
	output := &CSVMap{}

	inputHeaders, err := reader.Read()
	if err != nil {
		return nil, err
	}

	// Use our methods (defined above) to populate our struct fields
	output.Headers = inputHeaders
	output.Reader = reader
	output.HeaderIndexMap = output.CreateHeaderIndexMap(inputHeaders)

	return output, nil
}

// returns a new CSVMap object.
func NewFromReader(reader *csv.Reader) (*CSVMap, error) {
	// Create our resulting struct
	output := &CSVMap{}

	inputHeaders, err := reader.Read()
	if err != nil {
		return nil, err
	}

	// Use our methods (defined above) to populate our struct fields
	output.Headers = inputHeaders
	output.Reader = reader
	output.HeaderIndexMap = output.CreateHeaderIndexMap(inputHeaders)

	return output, nil
}
